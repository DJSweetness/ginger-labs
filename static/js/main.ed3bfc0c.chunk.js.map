{"version":3,"sources":["utils.tsx","Components/GiphyGrid/GiphyGrid.tsx","Components/Pagination/Pagination.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["fetchGifs","inputValue","paginationOffset","a","fullEndpoint","fetch","response","json","data","pagination","GiphyGrid","gifDataArr","array","type","filter","item","filterGifs","giphyResponse","className","map","gifData","index","src","images","original","url","alt","title","Pagination","fetchNextPagination","paginationSize","setPaginationOffset","id","disabled","onClick","giphyResponseDefault","offset","App","inputRef","useRef","useState","setGiphyResponse","cache","setCache","lastFetchedInputVal","setLastFetchedInputVal","handleDataFetching","current","value","cacheKey","placeholder","ref","length","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ed3bfc0c.chunk.js","sourcesContent":["export type GiphyResponseType = {\r\n    data: {\r\n        images: {\r\n            original: {\r\n                url: string;\r\n            };\r\n        };\r\n        type: string;\r\n        title: string;\r\n    }[];\r\n    pagination: {\r\n        offset: number;\r\n    }\r\n};\r\n\r\nexport async function fetchGifs(inputValue: string, paginationOffset: number): Promise<GiphyResponseType> {\r\n    const apiKey = 'brXMsD0cTFgrd7yQh6u17ilSMIhDz2t9';\r\n    const endpoint = 'https://api.giphy.com/v1/gifs/search';\r\n    const fullEndpoint = `${endpoint}?q=${inputValue}&api_key=${apiKey}&offset=${paginationOffset}`;\r\n    const response = await fetch(fullEndpoint);\r\n    const { data, pagination }: GiphyResponseType  = await response.json();\r\n    \r\n    return {\r\n        data,\r\n        pagination\r\n    };\r\n}","import { GiphyResponseType } from './../../utils';\r\nimport './giphy-grid.css';\r\n\r\nfunction filterGifs(array: GiphyResponseType['data'], type = 'gif'): GiphyResponseType['data'] {\r\n    return array.filter(item => item.type === type);\r\n}\r\n\r\n\r\nexport function GiphyGrid({\r\n    giphyResponse\r\n}: {\r\n    giphyResponse: GiphyResponseType\r\n}) {\r\n    const giphyDataArray = giphyResponse.data;\r\n    const gifDataArr = filterGifs(giphyDataArray);\r\n\r\n    // Simply iterates over the data from giphy and let's css handle the formatting\r\n    return (\r\n        <div className='gallery'>\r\n            {\r\n                \r\n                gifDataArr.map((gifData, index) => \r\n                    <img\r\n                        key={`${gifData.title}-${index}`}\r\n                        className='gif-image'\r\n                        src={gifData.images.original.url}\r\n                        alt={gifData.title}\r\n                    />\r\n                )\r\n            }\r\n        </div>\r\n    )\r\n}","import React from 'react';\r\nimport './pagination.css';\r\n\r\nexport function Pagination(\r\n    {\r\n        fetchNextPagination,\r\n        paginationOffset,\r\n        paginationSize,\r\n        setPaginationOffset\r\n    }: \r\n    {\r\n        fetchNextPagination: (index: number) => void;\r\n        paginationOffset: number;\r\n        paginationSize: number;\r\n        setPaginationOffset: React.Dispatch<React.SetStateAction<number>>\r\n    }\r\n) {\r\n    // Previous and Next handlers to fetch new data \r\n    function handlePreviousClick() {\r\n        setPaginationOffset(paginationOffset - paginationSize);\r\n        fetchNextPagination(paginationOffset - paginationSize);\r\n    }\r\n    function handleNextClick() {\r\n        setPaginationOffset(paginationOffset + paginationSize);\r\n        fetchNextPagination(paginationOffset + paginationSize);\r\n    }\r\n\r\n    return (\r\n        <div id='pagination-button'>\r\n            <button\r\n                id='pagination-button'\r\n                disabled={paginationOffset === 0}\r\n                onClick={handlePreviousClick}\r\n            >\r\n                Prev\r\n            </button>\r\n            <button\r\n                onClick={handleNextClick}\r\n            >\r\n                Next\r\n            </button>\r\n        </div>\r\n    )\r\n}","import React, { useRef, useState } from 'react';\nimport './App.css';\nimport { fetchGifs, GiphyResponseType } from './utils';\nimport { GiphyGrid } from './Components/GiphyGrid/GiphyGrid';\nimport { Pagination } from './Components/Pagination/Pagination';\n\nconst giphyResponseDefault = {\n  data: [],\n  pagination: { offset: 0 }\n};\n\nfunction App() {\n  const inputRef = useRef<HTMLInputElement | null>(null);\n  const [giphyResponse, setGiphyResponse] = useState<GiphyResponseType>(giphyResponseDefault);\n  const [cache, setCache] = useState<Record<string, GiphyResponseType>>({});\n  const [paginationOffset, setPaginationOffset] = useState(0);\n  const [lastFetchedInputVal, setLastFetchedInputVal] = useState('');\n  const dataFetchSize = 50; // default of giphy request - used for fetching with pagination and search\n\n  function handleDataFetching(offset: number) {\n    const inputValue = inputRef?.current?.value || lastFetchedInputVal;\n\n    if (inputValue) {\n      const cacheKey = inputValue + offset;\n\n      // This is our caching logic, we maintain a key/value pair\n      // the key being what we've searched for (including offset)\n      // and the value is the response from the fetch\n      if (cache[cacheKey]) {\n        setGiphyResponse(cache[cacheKey]);\n      } else {\n        (async () => { // IIFE for simplicity\n          const giphyResponse = await fetchGifs(inputValue, offset);\n  \n          // Store response in cache\n          setCache({\n            ...cache,\n            [cacheKey]: giphyResponse\n          });\n\n          // Store results and set the last input value so when we paginate\n          // it makes use of the same functionality and only the offset changes\n          setGiphyResponse(giphyResponse);\n          setLastFetchedInputVal(inputValue);\n        })();\n      }\n    }\n  }\n\n  // Used for initial/new searches\n  function handleSearchClick() {\n    handleDataFetching(0);\n    setPaginationOffset(0);\n  }\n\n  return (\n    <div id='app-container'>\n      <div id='search-container'>\n        <input id='input-search' type='search' placeholder='Search Giphy here' ref={inputRef} />\n        <button id='add-filter-button' type='submit' onClick={handleSearchClick}>Search</button>\n      </div>\n      {\n        giphyResponse.data.length > 0 &&\n        <Pagination\n          fetchNextPagination={handleDataFetching}\n          paginationOffset={paginationOffset}\n          setPaginationOffset={setPaginationOffset}\n          paginationSize={dataFetchSize}\n        />\n      }\n      <div>\n        {\n          giphyResponse.data.length === 0\n            ?\n              <div>No Results</div>\n            :\n              <GiphyGrid giphyResponse={giphyResponse} />\n        }\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}